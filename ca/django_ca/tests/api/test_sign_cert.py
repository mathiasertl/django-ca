# This file is part of django-ca (https://github.com/mathiasertl/django-ca).
#
# django-ca is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# django-ca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with django-ca. If not, see
# <http://www.gnu.org/licenses/>.

# pylint: disable=redefined-outer-name  # requested pytest fixtures show up this way.

"""Test the signing certificates via the API."""

import base64
import ipaddress
from datetime import timedelta
from http import HTTPStatus
from typing import Any

from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.serialization import Encoding
from cryptography.x509.oid import AuthorityInformationAccessOID, ExtendedKeyUsageOID, ExtensionOID, NameOID

from django.contrib.auth.models import AbstractUser
from django.db.models import Model
from django.test.client import Client
from django.urls import reverse, reverse_lazy
from django.utils import timezone

import pytest
from freezegun import freeze_time
from pytest_django.fixtures import SettingsWrapper

from django_ca import constants
from django_ca.conf import model_settings
from django_ca.models import Certificate, CertificateAuthority, CertificateOrder
from django_ca.tests.api.conftest import APIPermissionTestBase
from django_ca.tests.base.constants import CERT_DATA, TIMESTAMPS
from django_ca.tests.base.typehints import CaptureOnCommitCallbacks, HttpResponse
from django_ca.tests.base.utils import (
    certificate_policies,
    crl_distribution_points,
    distribution_point,
    dns,
    extended_key_usage,
    freshest_crl,
    ip,
    iso_format,
    key_usage,
    ocsp_no_check,
    rdn,
    subject_alternative_name,
    tls_feature,
    uri,
)

pytestmark = [pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])]

path = reverse_lazy("django_ca:api:sign_certificate", kwargs={"serial": CERT_DATA["root"]["serial"]})
default_subject = [{"oid": NameOID.COMMON_NAME.dotted_string, "value": "api.example.com"}]
csr = CERT_DATA["root-cert"]["csr"]["parsed"].public_bytes(Encoding.PEM).decode("utf-8")


@pytest.fixture(scope="module")
def api_permission() -> tuple[type[Model], str]:
    """Fixture for the permission required by this view."""
    return Certificate, "sign_certificate"


@pytest.fixture
def expected_response() -> dict[str, Any]:
    """Fixture for the non-dynamic parts of the expected response."""
    return {
        "created": iso_format(TIMESTAMPS["everything_valid"]),
        "updated": iso_format(TIMESTAMPS["everything_valid"]),
        "status": "pending",
        "user": "user",
        "serial": None,
    }


def request(client: Client, data: dict[str, Any]) -> HttpResponse:
    """Shortcut to run a request."""
    return client.post(path, data, content_type="application/json")


def sign_certificate(
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
    user: AbstractUser,
    client: Client,
    ca: CertificateAuthority,
    data: dict[str, Any],
    expected_response: dict[str, Any],
    expected_algorithm: hashes.HashAlgorithm | None = None,
) -> Certificate:
    """Common function to issue a certificate signing request."""
    data["csr"] = csr

    # Issue a signing request
    with django_capture_on_commit_callbacks(execute=True) as callbacks:
        response = request(client, data)
        assert response.status_code == HTTPStatus.OK, response.content.decode()

        # Get order before on_commit callbacks are called to test pending state
        order: CertificateOrder = CertificateOrder.objects.get(certificate_authority=ca)
        assert order.status == CertificateOrder.STATUS_PENDING
        assert order.certificate is None
        assert order.user == user

    # Make sure that there was a callback
    assert len(callbacks) == 1

    # Test that the response looks okay
    expected_response["slug"] = order.slug
    assert response.json() == expected_response

    # Get certificate and validate some properties
    cert: Certificate = Certificate.objects.get(ca=ca, cn="api.example.com")
    assert cert.profile == data.get("profile", model_settings.CA_DEFAULT_PROFILE)
    assert cert.autogenerated is data.get("autogenerated", False)
    assert cert.algorithm == expected_algorithm or ca.algorithm
    assert cert.csr.pem == csr

    # Test the order in its final state
    order.refresh_from_db()
    assert order.status == CertificateOrder.STATUS_ISSUED
    assert order.certificate == cert

    # Get updated order object
    order_path = reverse(
        "django_ca:api:get_certificate_order", kwargs={"serial": ca.serial, "slug": order.slug}
    )
    order_response = client.get(order_path)

    # Update expected response with dynamic data
    expected_response["status"] = "issued"
    expected_response["serial"] = cert.serial

    assert order_response.status_code == HTTPStatus.OK, response.content
    assert order_response.json() == expected_response

    return cert


def test_sign_ca_values(
    api_user: AbstractUser,
    api_client: Client,
    usable_root: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test that CA extensions are added."""
    cert = sign_certificate(
        django_capture_on_commit_callbacks,
        api_user,
        api_client,
        ca=usable_root,
        data={"subject": default_subject},
        expected_response=expected_response,
    )

    extensions = cert.extensions

    # Test signed extensions
    assert (
        extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS] == usable_root.sign_authority_information_access
    )
    assert extensions[ExtensionOID.CRL_DISTRIBUTION_POINTS] == usable_root.sign_crl_distribution_points


def test_private_key_unavailable(
    api_user: AbstractUser,
    api_client: Client,
    root: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test the error when no private key is available."""
    with django_capture_on_commit_callbacks() as callbacks:
        response = request(api_client, {"csr": csr, "subject": default_subject})

        # Get order before on_commit callbacks are called to test pending state
        order: CertificateOrder = CertificateOrder.objects.get(certificate_authority=root)
        assert order.status == CertificateOrder.STATUS_PENDING
        assert order.certificate is None
        assert order.user == api_user

    # Make sure that there was a callback
    assert len(callbacks) == 1

    # Test that the response looks okay
    assert response.status_code == HTTPStatus.OK, response.content
    expected_response["slug"] = order.slug
    assert response.json() == expected_response


def test_key_backend_options(
    settings: SettingsWrapper,
    api_client: Client,
    usable_pwd: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test passing key backend options."""
    settings.CA_PASSWORDS = {}

    usable_pwd.api_enabled = True
    usable_pwd.save()

    path = reverse_lazy("django_ca:api:sign_certificate", kwargs={"serial": usable_pwd.serial})
    pwd = base64.b64encode(CERT_DATA["pwd"]["password"])  # pwd needs to be base64 encoded
    data = {
        "csr": csr,
        "subject": default_subject,
        "key_backend_options": {"password": pwd.decode("utf-8")},
    }
    with django_capture_on_commit_callbacks(execute=True):
        response = api_client.post(path, data, content_type="application/json")
        assert response.status_code == HTTPStatus.OK, response.content

    order: CertificateOrder = CertificateOrder.objects.get(certificate_authority=usable_pwd)
    expected_response["slug"] = order.slug
    assert response.json() == expected_response

    cert = Certificate.objects.get(ca=usable_pwd)
    assert cert.serial


def test_key_backend_configuration_not_required_on_frontend(
    api_user: AbstractUser,
    api_client: Client,
    usable_pwd: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test that the API endpoint does not need to know about the key backend or any options."""
    usable_pwd.key_backend_alias = "unknown"  # frontend does not know about the CAs key backend at all
    usable_pwd.api_enabled = True
    usable_pwd.save()

    path = reverse_lazy("django_ca:api:sign_certificate", kwargs={"serial": usable_pwd.serial})
    data = {"csr": csr, "subject": default_subject}
    with django_capture_on_commit_callbacks() as callbacks:
        response = api_client.post(path, data, content_type="application/json")
        assert response.status_code == HTTPStatus.OK, response.content

    # Get order before on_commit callbacks are called to test pending state
    order: CertificateOrder = CertificateOrder.objects.get(certificate_authority=usable_pwd)
    assert order.status == CertificateOrder.STATUS_PENDING
    assert order.certificate is None
    assert order.user == api_user

    # Test that there was a callback.
    assert len(callbacks) == 1

    expected_response["slug"] = order.slug
    assert response.json() == expected_response


def test_sign_certificate_with_parameters(
    api_user: AbstractUser,
    api_client: Client,
    usable_root: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test signing with parameters."""
    not_after = timezone.now() + timedelta(days=73)

    cert = sign_certificate(
        django_capture_on_commit_callbacks,
        api_user,
        api_client,
        ca=usable_root,
        data={
            "subject": default_subject,
            "autogenerated": True,
            "profile": "server",
            "not_after": iso_format(not_after),
            "algorithm": "SHA3/384",
        },
        expected_response=expected_response,
        expected_algorithm=hashes.SHA3_384(),
    )

    assert cert.not_after == not_after


def test_sign_certificate_with_extensions(
    api_user: AbstractUser,
    api_client: Client,
    usable_root: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test signing certificates with extensions."""
    cert = sign_certificate(
        django_capture_on_commit_callbacks,
        api_user,
        api_client,
        ca=usable_root,
        data={
            "subject": default_subject,
            "extensions": [
                {
                    "type": "authority_information_access",
                    "value": [
                        {
                            "access_method": "ca_issuers",
                            "access_location": {"type": "URI", "value": "http://api.issuer.example.com"},
                        },
                        {
                            "access_method": "ocsp",
                            "access_location": {"type": "URI", "value": "http://api.ocsp.example.com"},
                        },
                    ],
                },
                {
                    "type": "certificate_policies",
                    "value": [
                        {"policy_identifier": "1.1.1"},
                        {
                            "policy_identifier": "1.3.3",
                            "policy_qualifiers": [
                                "A policy qualifier as a string",
                                {
                                    "explicit_text": "An explicit text",
                                    "notice_reference": {
                                        "organization": "some org",
                                        "notice_numbers": [1, 2, 3],
                                    },
                                },
                            ],
                        },
                    ],
                },
                {
                    "type": "crl_distribution_points",
                    "value": [
                        {"full_name": [{"type": "URI", "value": "http://api.crl1.example.com"}]},
                        {
                            "full_name": [{"type": "URI", "value": "http://api.crl2.example.com"}],
                            "crl_issuer": [{"type": "URI", "value": "http://api.crl2.example.com"}],
                            "reasons": ["key_compromise"],
                        },
                        {
                            "relative_name": [
                                {"oid": NameOID.COMMON_NAME.dotted_string, "value": "example.com"}
                            ]
                        },
                    ],
                },
                {"type": "extended_key_usage", "value": ["serverAuth", "1.2.3"]},
                {
                    "type": "freshest_crl",
                    "value": [
                        {"full_name": [{"type": "URI", "value": "http://api.freshest-crl.example.com"}]}
                    ],
                },
                {"type": "key_usage", "value": ["key_encipherment"]},
                {"type": "ocsp_no_check"},
                {
                    "type": "subject_alternative_name",
                    "critical": not constants.EXTENSION_DEFAULT_CRITICAL[
                        ExtensionOID.SUBJECT_ALTERNATIVE_NAME
                    ],
                    "value": [{"type": "DNS", "value": "example.com"}, {"type": "IP", "value": "127.0.0.1"}],
                },
                {"type": "tls_feature", "value": ["OCSPMustStaple"]},
            ],
        },
        expected_response=expected_response,
    )

    # Test extensions
    exts = cert.extensions

    # Test Authority Information Access extension
    assert exts[ExtensionOID.AUTHORITY_INFORMATION_ACCESS] == x509.Extension(
        oid=ExtensionOID.AUTHORITY_INFORMATION_ACCESS,
        critical=False,
        value=x509.AuthorityInformationAccess(
            [
                x509.AccessDescription(
                    access_method=AuthorityInformationAccessOID.CA_ISSUERS,
                    access_location=uri("http://api.issuer.example.com"),
                ),
                x509.AccessDescription(
                    access_method=AuthorityInformationAccessOID.OCSP,
                    access_location=uri("http://api.ocsp.example.com"),
                ),
            ]
        ),
    )

    # Test Certificate Policies extension
    assert exts[ExtensionOID.CERTIFICATE_POLICIES] == certificate_policies(
        x509.PolicyInformation(policy_identifier=x509.ObjectIdentifier("1.1.1"), policy_qualifiers=None),
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("1.3.3"),
            policy_qualifiers=[
                "A policy qualifier as a string",
                x509.UserNotice(
                    notice_reference=x509.NoticeReference(organization="some org", notice_numbers=[1, 2, 3]),
                    explicit_text="An explicit text",
                ),
            ],
        ),
    )

    # Test CRL Distribution Points extension
    assert exts[ExtensionOID.CRL_DISTRIBUTION_POINTS] == crl_distribution_points(
        distribution_point(full_name=[uri("http://api.crl1.example.com")]),
        distribution_point(
            full_name=[uri("http://api.crl2.example.com")],
            crl_issuer=[uri("http://api.crl2.example.com")],
            reasons=frozenset([x509.ReasonFlags.key_compromise]),
        ),
        distribution_point(relative_name=rdn([(NameOID.COMMON_NAME, "example.com")])),
    )

    # Test Extended Key Usage extension
    assert exts[ExtensionOID.EXTENDED_KEY_USAGE] == extended_key_usage(
        ExtendedKeyUsageOID.SERVER_AUTH, x509.ObjectIdentifier("1.2.3")
    )

    # Test Freshest CRL extension
    assert exts[ExtensionOID.FRESHEST_CRL] == freshest_crl(
        distribution_point(full_name=[uri("http://api.freshest-crl.example.com")])
    )

    # Test Key Usage extension
    assert exts[ExtensionOID.KEY_USAGE] == key_usage(key_encipherment=True)

    # Test OCSPNoCheck extension
    assert exts[ExtensionOID.OCSP_NO_CHECK] == ocsp_no_check()

    # Test Subject Alternative Name extension
    assert exts[ExtensionOID.SUBJECT_ALTERNATIVE_NAME] == subject_alternative_name(
        dns("example.com"), ip(ipaddress.IPv4Address("127.0.0.1")), critical=True
    )

    # Test TLSFeature extension
    assert exts[ExtensionOID.TLS_FEATURE] == tls_feature(x509.TLSFeatureType.status_request)


if hasattr(x509, "Admissions"):

    @pytest.mark.parametrize(
        ("data", "expected"),
        (
            ({"admissions": []}, x509.Admissions(authority=None, admissions=[])),
            (
                {
                    "authority": {"type": "URI", "value": "https://auth.example.com"},
                    "admissions": [
                        {
                            "admission_authority": {
                                "type": "URI",
                                "value": "https://auth.admission.example.com",
                            },
                            "naming_authority": {
                                "id": "1.2.3",
                                "url": "https://url.example.com",
                                "text": "text example",
                            },
                            "profession_infos": [
                                {"profession_items": ["prof item"]},
                                {
                                    "naming_authority": {
                                        "id": "1.2.3.4",
                                        "url": "https://url.prof-info.example.com",
                                        "text": "text prof-info example",
                                    },
                                    "profession_items": ["prof item2"],
                                    "profession_oids": ["1.2.3.5"],
                                    "registration_number": "reg number",
                                    "add_profession_info": "Zm9vYmFy",
                                },
                            ],
                        }
                    ],
                },
                x509.Admissions(
                    authority=uri("https://auth.example.com"),
                    admissions=[
                        x509.Admission(
                            admission_authority=uri("https://auth.admission.example.com"),
                            naming_authority=x509.NamingAuthority(
                                id=x509.ObjectIdentifier("1.2.3"),
                                url="https://url.example.com",
                                text="text example",
                            ),
                            profession_infos=[
                                x509.ProfessionInfo(
                                    naming_authority=None,
                                    profession_items=["prof item"],
                                    profession_oids=None,
                                    registration_number=None,
                                    add_profession_info=None,
                                ),
                                x509.ProfessionInfo(
                                    naming_authority=x509.NamingAuthority(
                                        id=x509.ObjectIdentifier("1.2.3.4"),
                                        url="https://url.prof-info.example.com",
                                        text="text prof-info example",
                                    ),
                                    profession_items=["prof item2"],
                                    profession_oids=[x509.ObjectIdentifier("1.2.3.5")],
                                    registration_number="reg number",
                                    add_profession_info=b"foobar",
                                ),
                            ],
                        )
                    ],
                ),
            ),
        ),
    )
    def test_sign_certificate_with_admissions_extension(
        api_user: AbstractUser,
        api_client: Client,
        usable_root: CertificateAuthority,
        expected_response: dict[str, Any],
        django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
        data: dict[str, Any],
        expected: "x509.Admission",
    ) -> None:
        """Test signing certificates with extensions."""
        cert = sign_certificate(
            django_capture_on_commit_callbacks,
            api_user,
            api_client,
            ca=usable_root,
            data={
                "subject": default_subject,
                "extensions": [{"type": "admissions", "value": data}],
            },
            expected_response=expected_response,
        )

        # Test extensions
        exts = cert.extensions
        assert exts[ExtensionOID.ADMISSIONS].value == expected


def test_sign_certificate_with_subject_alternative_name(
    api_user: AbstractUser,
    api_client: Client,
    usable_root: CertificateAuthority,
    expected_response: dict[str, Any],
    django_capture_on_commit_callbacks: CaptureOnCommitCallbacks,
) -> None:
    """Test signing certificates with an additional subject alternative name."""
    cert = sign_certificate(
        django_capture_on_commit_callbacks,
        api_user,
        api_client,
        ca=usable_root,
        data={
            "subject": default_subject,
            "extensions": [
                {
                    "type": "subject_alternative_name",
                    "critical": not constants.EXTENSION_DEFAULT_CRITICAL[
                        ExtensionOID.SUBJECT_ALTERNATIVE_NAME
                    ],
                    "value": [{"type": "DNS", "value": "example.com"}, {"type": "IP", "value": "127.0.0.1"}],
                },
            ],
        },
        expected_response=expected_response,
    )

    # Test SubjectAlternativeName extension
    extensions = cert.extensions

    # Test Subject Alternative Name extension
    assert extensions[ExtensionOID.SUBJECT_ALTERNATIVE_NAME] == subject_alternative_name(
        dns("example.com"), ip(ipaddress.IPv4Address("127.0.0.1")), critical=True
    )


def test_invalid_csr(api_client: Client) -> None:
    """Test passing an unparseable CSR."""
    data = {"subject": default_subject, "csr": "unparsable"}
    response = request(api_client, data)
    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY, response.json()
    assert response.json() == {
        "detail": [
            {
                "ctx": {"error": "Invalid PEM data."},
                "loc": ["body", "data", "csr"],
                "msg": "Value error, Invalid PEM data.",
                "type": "value_error",
            }
        ]
    }


def test_invalid_csr_with_valid_headers(api_client: Client) -> None:
    """Test passing an unparseable CSR that at least has valid delimiters."""
    data = {
        "subject": default_subject,
        "csr": "-----BEGIN CERTIFICATE REQUEST-----\n...\n-----END CERTIFICATE REQUEST-----\n",
    }
    response = request(api_client, data)
    assert response.status_code == HTTPStatus.BAD_REQUEST, response.json()
    assert response.json() == {"detail": "Unable to parse CSR."}


@pytest.mark.usefixtures("tmpcadir")
def test_crldp_with_full_name_and_relative_name(api_client: Client) -> None:
    """Test sending a CRL Distribution point with a full_name and a relative_name."""
    response = request(
        api_client,
        {
            "csr": csr,
            "subject": default_subject,
            "extensions": [
                {
                    "type": "crl_distribution_points",
                    "value": [
                        {
                            "full_name": [{"type": "URI", "value": "http://api.crl1.example.com"}],
                            "relative_name": [
                                {"oid": NameOID.COMMON_NAME.dotted_string, "value": "example.com"}
                            ],
                        },
                    ],
                },
            ],
        },
    )
    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY, response.json()
    assert response.json() == {
        "detail": [
            {
                "ctx": {"error": "must give exactly one of full_name or relative_name."},
                "loc": ["body", "data", "extensions", 0, "crl_distribution_points", "value", 0],
                "msg": "Value error, must give exactly one of full_name or relative_name.",
                "type": "value_error",
            }
        ]
    }


@pytest.mark.usefixtures("tmpcadir")
@freeze_time(TIMESTAMPS["everything_valid"])
def test_crldp_with_no_full_name_or_relative_name(api_client: Client) -> None:
    """Test sending a CRL Distribution point with neither a full name nor a relative name."""
    response = request(
        api_client,
        {
            "csr": csr,
            "subject": default_subject,
            "extensions": [{"type": "crl_distribution_points", "value": [{}]}],
        },
    )
    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY, response.json()
    assert response.json() == {
        "detail": [
            {
                "type": "value_error",
                "loc": ["body", "data", "extensions", 0, "crl_distribution_points", "value", 0],
                "msg": "Value error, either full_name, relative_name or crl_issuer must be provided.",
                "ctx": {"error": "either full_name, relative_name or crl_issuer must be provided."},
            }
        ]
    }


@pytest.mark.usefixtures("tmpcadir")
def test_with_invalid_algorithm(api_client: Client) -> None:
    """Test sending an invalid key usage."""
    response = request(api_client, {"csr": csr, "subject": default_subject, "algorithm": "foo"})
    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY, response.json()

    literal = "'SHA-224', 'SHA-256', 'SHA-384', 'SHA-512', 'SHA3/224', 'SHA3/256', 'SHA3/384' or 'SHA3/512'"
    assert response.json() == {
        "detail": [
            {
                "type": "literal_error",
                "loc": ["body", "data", "algorithm"],
                "msg": f"Input should be {literal}",
                "ctx": {"expected": literal},
            }
        ]
    }


@pytest.mark.usefixtures("tmpcadir")
def test_with_invalid_key_usage(api_client: Client) -> None:
    """Test sending an invalid key usage."""
    response = request(
        api_client,
        {"csr": csr, "subject": default_subject, "extensions": [{"type": "key_usage", "value": ["unknown"]}]},
    )
    assert response.status_code == HTTPStatus.UNPROCESSABLE_ENTITY, response.json()

    literal = (
        "'crl_sign', 'data_encipherment', 'decipher_only', 'digital_signature', 'encipher_only', "
        "'key_agreement', 'key_cert_sign', 'key_encipherment' or 'content_commitment'"
    )
    assert response.json() == {
        "detail": [
            {
                "type": "literal_error",
                "loc": ["body", "data", "extensions", 0, "key_usage", "value", 0],
                "msg": f"Input should be {literal}",
                "ctx": {"expected": literal},
            }
        ]
    }


@pytest.mark.usefixtures("tmpcadir", "usable_root")
@freeze_time(TIMESTAMPS["everything_expired"])
def test_expired_ca(api_client: Client) -> None:
    """Test that you can *not* sign a certificate for an expired CA."""
    response = request(api_client, {"csr": csr, "subject": default_subject})
    assert response.status_code == HTTPStatus.NOT_FOUND, response.content
    assert response.json() == {"detail": "Not Found"}, response.json()


class TestPermissions(APIPermissionTestBase):
    """Test permissions for this view."""

    path = path

    def request(self, client: Client) -> HttpResponse:
        """Standard request for testing permissions."""
        return request(client, {"csr": csr, "subject": default_subject})
