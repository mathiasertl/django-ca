# This file is part of django-ca (https://github.com/mathiasertl/django-ca).
#
# django-ca is free software: you can redistribute it and/or modify it under the terms of the GNU General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your
# option) any later version.
#
# django-ca is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the
# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along with django-ca. If not, see
# <http://www.gnu.org/licenses/>.

"""Test the init_ca management command."""

import io
import re
from collections.abc import Iterator
from datetime import timedelta
from typing import Any
from unittest.mock import MagicMock, call, patch

from cryptography import x509
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import dsa, ec
from cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey
from cryptography.hazmat.primitives.asymmetric.rsa import RSAPrivateKey, RSAPublicKey
from cryptography.x509.oid import AuthorityInformationAccessOID, ExtensionOID, NameOID

from django.conf import settings
from django.core.management import CommandError
from django.urls import reverse
from django.utils import timezone

import pytest
from pytest_django.fixtures import SettingsWrapper

from django_ca import constants
from django_ca.celery.messages import UseCertificateAuthorityTaskArgs
from django_ca.conf import model_settings
from django_ca.constants import ExtendedKeyUsageOID
from django_ca.key_backends import key_backends
from django_ca.key_backends.db import DBBackend
from django_ca.key_backends.db.models import DBUsePrivateKeyOptions
from django_ca.key_backends.hsm import HSMBackend
from django_ca.key_backends.hsm.models import HSMUsePrivateKeyOptions
from django_ca.key_backends.storages import StoragesBackend
from django_ca.key_backends.storages.models import StoragesUsePrivateKeyOptions
from django_ca.models import Certificate, CertificateAuthority
from django_ca.signals import post_create_ca
from django_ca.tests.base.assertions import (
    assert_authority_key_identifier,
    assert_ca_properties,
    assert_certificate,
    assert_command_error,
    assert_create_ca_signals,
    assert_crls,
    assert_e2e_error,
    assert_extensions,
    assert_signature,
    assert_system_exit,
)
from django_ca.tests.base.constants import CERT_DATA, CRYPTOGRAPHY_VERSION, TIMESTAMPS
from django_ca.tests.base.utils import (
    DummyBackend,
    authority_information_access,
    basic_constraints,
    certificate_policies,
    cmd,
    cmd_e2e,
    crl_distribution_points,
    distribution_point,
    dns,
    extended_key_usage,
    issuer_alternative_name,
    key_usage,
    name_constraints,
    ocsp_no_check,
    subject_alternative_name,
    uri,
)
from django_ca.typehints import (
    EllipticCurveName,
    ParsableKeyType,
    SignatureHashAlgorithm,
    SignatureHashAlgorithmName,
)
from django_ca.utils import add_colons

use_options = StoragesUsePrivateKeyOptions(password=None)

# pylint: disable=redefined-outer-name  # disabled because of fixtures


@pytest.fixture
def generate_crl() -> Iterator[MagicMock]:
    """Mock generate_crl task."""
    with patch("django_ca.management.commands.init_ca.generate_crl", autospec=True) as task_mock:
        yield task_mock


@pytest.fixture
def generate_ocsp_key() -> Iterator[MagicMock]:
    """Mock generate_ocsp_key task."""
    with patch("django_ca.management.commands.init_ca.generate_ocsp_key", autospec=True) as task_mock:
        yield task_mock


@pytest.fixture
def mock_tasks(generate_crl: MagicMock, generate_ocsp_key: MagicMock) -> Iterator[None]:
    """Simply mute Celery tasks and test that they were called once."""
    yield
    generate_crl.assert_called_once()
    generate_ocsp_key.assert_called_once()


def assert_post_create_ca(post: MagicMock, ca: CertificateAuthority) -> None:
    """Assert that the post_create_ca signal was called."""
    post.assert_called_once_with(ca=ca, signal=post_create_ca, sender=CertificateAuthority)


def assert_ocsp_responder_certificate(ca: CertificateAuthority) -> Certificate:
    """Assert properties of the OCSP responder certificate."""
    cert: Certificate = Certificate.objects.get(ca=ca, autogenerated=True)
    expected_authority_information_access = x509.Extension(
        oid=ExtensionOID.AUTHORITY_INFORMATION_ACCESS,
        critical=ca.sign_authority_information_access.critical,  # type: ignore[union-attr]
        value=x509.AuthorityInformationAccess(
            [
                ad
                for ad in ca.sign_authority_information_access.value  # type: ignore[union-attr]
                if ad.access_method == AuthorityInformationAccessOID.CA_ISSUERS
            ]
        ),
    )
    assert_extensions(
        cert,
        [
            ocsp_no_check(),
            extended_key_usage(ExtendedKeyUsageOID.OCSP_SIGNING),
            key_usage(digital_signature=True, content_commitment=True, key_encipherment=True),
            expected_authority_information_access,
        ],
        signer=ca,
    )
    return cert


def init_ca(name: str, **kwargs: Any) -> CertificateAuthority:
    """Run a basic init_ca command."""
    stdout = io.StringIO()
    stderr = io.StringIO()
    if kwargs.get("key_type", "RSA") in ("RSA", "DSA"):
        kwargs.setdefault("key_size", model_settings.CA_MIN_KEY_SIZE)

    out, err = cmd(
        "init_ca",
        name,
        f"C=AT,ST=Vienna,L=Vienna,O=Org,OU=OrgUnit,CN={name}",
        stdout=stdout,
        stderr=stderr,
        **kwargs,
    )
    ca = CertificateAuthority.objects.get(name=name)

    assert out == f"{add_colons(ca.serial)}\n"
    assert err == ""
    return ca


def init_ca_e2e(
    name: str, subject: str, *args: str, chain: list[CertificateAuthority] | None = None
) -> CertificateAuthority:
    """Run a init_ca command via cmd_e2e()."""
    if chain is None:
        chain = []

    with assert_create_ca_signals() as (_pre, post):
        out, err = cmd_e2e(["init_ca", name, subject, *args])
        ca = CertificateAuthority.objects.get(name=name)
        assert out == f"{add_colons(ca.serial)}\n"
        assert err == ""

    ca = CertificateAuthority.objects.get(name=name)
    assert_post_create_ca(post, ca)
    assert_signature([*chain, ca], ca)
    ca.full_clean()  # assert e.g. max_length in serials
    return ca


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])  # otherwise CRLs might have rounding errors
def test_basic(
    ca_name: str,
    subject: x509.Name,
    rfc4514_subject: str,
    key_backend: StoragesBackend,
    generate_crl: MagicMock,
    generate_ocsp_key: MagicMock,
) -> None:
    """Basic tests for the command."""
    ca = init_ca_e2e(ca_name, rfc4514_subject)
    assert_ca_properties(ca, ca_name)
    assert_certificate(ca, subject)

    assert ca.path_length == 0
    assert ca.max_path_length == 0
    assert ca.allows_intermediate_ca is False

    # test the private key
    key = key_backend.get_key(ca, use_options)
    assert isinstance(key, RSAPrivateKey)
    assert key.key_size == 1024
    assert_authority_key_identifier(ca, ca)

    # Test that extensions that do not work for root CAs are NOT present
    assert ExtensionOID.AUTHORITY_INFORMATION_ACCESS not in ca.extensions
    assert ExtensionOID.CRL_DISTRIBUTION_POINTS not in ca.extensions

    # Validate OCSP responder certificate and cached CRLs
    generate_crl.assert_called_once_with(UseCertificateAuthorityTaskArgs(serial=ca.serial))
    generate_ocsp_key.assert_called_once_with(UseCertificateAuthorityTaskArgs(serial=ca.serial))


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])  # otherwise CRLs might have rounding errors
def test_basic_without_timezone_support(
    settings: SettingsWrapper,
    ca_name: str,
    subject: x509.Name,
    rfc4514_subject: str,
    key_backend: StoragesBackend,
    generate_crl: MagicMock,
    generate_ocsp_key: MagicMock,
) -> None:
    """Basic test without timezone support."""
    settings.USE_TZ = True
    return test_basic(ca_name, subject, rfc4514_subject, key_backend, generate_crl, generate_ocsp_key)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])  # otherwise CRLs might have rounding errors
def test_arguments(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test most arguments."""
    hostname = "example.com"
    website = f"https://{hostname}"
    tos = f"{website}/tos/"
    caa = f"caa.{hostname}"

    ca = init_ca_e2e(
        ca_name,
        "CN={self.hostname}",
        "--algorithm=SHA-256",  # hashes.SHA256(),
        "--key-type=EC",
        "--expires=720",
        "--sign-ca-issuer=http://issuer.ca.example.com",
        "--sign-issuer-alternative-name=http://ian.ca.example.com",
        "--sign-crl-full-name=http://crl.example.com",
        "--sign-ocsp-responder=http://ocsp.example.com",
        f"--caa={caa}",
        f"--website={website}",
        f"--tos={tos}",
    )

    actual = ca.extensions
    assert ExtensionOID.CRL_DISTRIBUTION_POINTS not in actual

    # test the private key
    key = key_backend.get_key(ca, use_options)
    assert isinstance(key, ec.EllipticCurvePrivateKey)
    assert key.key_size == 256

    assert isinstance(ca.pub.loaded.signature_hash_algorithm, hashes.SHA256)
    assert isinstance(ca.pub.loaded.public_key(), ec.EllipticCurvePublicKey)
    assert ca.issuer == ca.subject
    assert ca.path_length == 0
    assert ca.max_path_length == 0
    assert ca.allows_intermediate_ca is False
    assert ca.sign_authority_information_access == authority_information_access(
        ca_issuers=[uri("http://issuer.ca.example.com")], ocsp=[uri("http://ocsp.example.com")]
    )
    assert ca.sign_issuer_alternative_name == issuer_alternative_name(uri("http://ian.ca.example.com"))

    assert ca.sign_crl_distribution_points == crl_distribution_points(
        distribution_point([uri("http://crl.example.com")])
    )
    assert_authority_key_identifier(ca, ca)

    # test non-extension properties
    assert ca.caa_identity == caa
    assert ca.website == website
    assert ca.terms_of_service == tos

    # test acme properties
    assert ca.acme_enabled is False
    assert ca.acme_registration is True
    assert ca.acme_requires_contact is True


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_arguments_without_timezone_support(
    settings: SettingsWrapper, ca_name: str, key_backend: StoragesBackend
) -> None:
    """Test arguments without timezone support."""
    settings.USE_TZ = False
    test_arguments(ca_name, key_backend)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_add_extensions(hostname: str, ca_name: str) -> None:
    """Test adding various extensions."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        # Basic Constraints extension
        "--path-length=3",
        # Certificate Policies extension
        "--policy-identifier=anyPolicy",
        "--certification-practice-statement=https://example.com/cps1/",
        "--user-notice=user notice text one",
        "--policy-identifier=1.2.3",
        "--user-notice=user notice text two",
        "--certification-practice-statement=https://example.com/cps2/",
        # Extended Key Usage extension
        "--extended-key-usage",
        "clientAuth",
        "1.3.6.1.5.5.7.3.1",  # == serverAuth, to test custom OIDs
        # Inhibit anyPolicy extension
        "--inhibit-any-policy",
        "1",
        # Issuer Alternative Name extension
        "--issuer-alternative-name",
        "DNS:ian.example.com",
        # Key Usage extension
        "--key-usage",
        "keyCertSign",
        "digitalSignature",
        # Name Constraints extension
        "--permit-name=DNS:.com",
        "--exclude-name=DNS:.net",
        # Policy Constraints extension
        "--inhibit-policy-mapping",
        "1",
        "--require-explicit-policy",
        "2",
        # Subject Alternative Name extension
        "--subject-alternative-name",
        "DNS:san.example.com",
        "--subject-alternative-name",
        "URI:https://san.example.net",
    )

    extensions = ca.extensions

    # Test BasicConstraints extension
    assert extensions[ExtensionOID.BASIC_CONSTRAINTS] == basic_constraints(True, 3)
    assert ca.path_length == 3
    assert ca.max_path_length == 3
    assert ca.allows_intermediate_ca is True

    # Test Certificate Policies extension
    assert extensions[ExtensionOID.CERTIFICATE_POLICIES] == certificate_policies(
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("2.5.29.32.0"),
            policy_qualifiers=[
                "https://example.com/cps1/",
                x509.UserNotice(notice_reference=None, explicit_text="user notice text one"),
            ],
        ),
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("1.2.3"),
            policy_qualifiers=[
                x509.UserNotice(notice_reference=None, explicit_text="user notice text two"),
                "https://example.com/cps2/",
            ],
        ),
    )

    # Test Extended Key Usage extension
    assert extensions[ExtensionOID.EXTENDED_KEY_USAGE] == extended_key_usage(
        ExtendedKeyUsageOID.CLIENT_AUTH, ExtendedKeyUsageOID.SERVER_AUTH
    )

    # Test Inhibit anyPolicy extension
    assert extensions[ExtensionOID.INHIBIT_ANY_POLICY] == x509.Extension(
        oid=ExtensionOID.INHIBIT_ANY_POLICY, critical=True, value=x509.InhibitAnyPolicy(1)
    )

    # Test Issuer Alternative Name extension
    assert extensions[ExtensionOID.ISSUER_ALTERNATIVE_NAME] == issuer_alternative_name(dns("ian.example.com"))

    # Test Key Usage extension
    assert extensions[ExtensionOID.KEY_USAGE] == key_usage(key_cert_sign=True, digital_signature=True)

    # Test Name Constraints extension
    assert extensions[ExtensionOID.NAME_CONSTRAINTS] == name_constraints(
        permitted=[dns(".com")], excluded=[dns(".net")], critical=True
    )

    # Test Policy Constraints extension
    assert extensions[ExtensionOID.POLICY_CONSTRAINTS] == x509.Extension(
        oid=ExtensionOID.POLICY_CONSTRAINTS,
        critical=True,
        value=x509.PolicyConstraints(inhibit_policy_mapping=1, require_explicit_policy=2),
    )

    # Test Subject Alternative Name extension
    assert extensions[ExtensionOID.SUBJECT_ALTERNATIVE_NAME] == subject_alternative_name(
        dns("san.example.com"), uri("https://san.example.net")
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_add_extensions_with_non_default_critical(hostname: str, ca_name: str) -> None:
    """Test setting non-default critical values."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        # Certificate Policies extension:
        "--policy-identifier=anyPolicy",
        "--certificate-policies-critical",
        # Extended Key Usage extension
        "--extended-key-usage",
        "clientAuth",
        "1.3.6.1.5.5.7.3.1",  # == serverAuth, to test custom OIDs
        "--extended-key-usage-critical",
        # Key Usage extension
        "--key-usage",
        "keyCertSign",
        "digitalSignature",
        "--key-usage-non-critical",
        # Subject Alternative Name extension
        "--subject-alternative-name",
        "DNS:san.example.com",
        "--subject-alternative-name",
        f"URI:https://san.{hostname}",
        "--subject-alternative-name-critical",
    )

    extensions = ca.extensions

    # Test Certificate Policies extension
    assert extensions[ExtensionOID.CERTIFICATE_POLICIES] == certificate_policies(
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("2.5.29.32.0"), policy_qualifiers=None
        ),
        critical=True,
    )

    # Test Extended Key Usage extension
    assert extensions[ExtensionOID.EXTENDED_KEY_USAGE] == extended_key_usage(
        ExtendedKeyUsageOID.CLIENT_AUTH, ExtendedKeyUsageOID.SERVER_AUTH, critical=True
    )

    # Test KeyUsage extension
    assert extensions[ExtensionOID.KEY_USAGE] == key_usage(
        key_cert_sign=True, digital_signature=True, critical=False
    )

    # Test Subject Alternative Name extension
    assert extensions[ExtensionOID.SUBJECT_ALTERNATIVE_NAME] == subject_alternative_name(
        dns("san.example.com"), uri(f"https://san.{hostname}"), critical=True
    )


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_add_extensions_with_formatting(
    hostname: str, ca_name: str, usable_root: CertificateAuthority
) -> None:
    """Test adding various extensions."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        f"--parent={usable_root.serial}",
        "--ocsp-responder=https://example.com/ocsp/{OCSP_PATH}",
        "--ca-issuer=https://example.com/ca-issuer/{CA_ISSUER_PATH}",
        "--crl-full-name=http://example.com/crl/{CRL_PATH}",
        "--crl-full-name=http://example.net/crl/{CRL_PATH}",
        chain=[usable_root],
    )

    extensions = ca.extensions
    ca_issuer_path = reverse("django_ca:issuer", kwargs={"serial": usable_root.serial})
    ocsp_path = reverse("django_ca:ocsp-ca-post", kwargs={"serial": usable_root.serial})
    crl_path = reverse("django_ca:ca-crl", kwargs={"serial": usable_root.serial})

    # Test AuthorityInformationAccess extension
    assert extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS] == authority_information_access(
        ca_issuers=[uri(f"https://example.com/ca-issuer{ca_issuer_path}")],
        ocsp=[uri(f"https://example.com/ocsp{ocsp_path}")],
    )

    # Test CRL Distribution Points extension
    assert extensions[ExtensionOID.CRL_DISTRIBUTION_POINTS] == crl_distribution_points(
        distribution_point(
            [uri(f"http://example.com/crl{crl_path}"), uri(f"http://example.net/crl{crl_path}")]
        )
    )


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_add_extensions_with_formatting_without_uri(
    hostname: str, ca_name: str, usable_root: CertificateAuthority
) -> None:
    """Test adding various extensions."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        f"--parent={usable_root.serial}",
        "--ocsp-responder=DNS:example.com",
        "--ca-issuer=DNS:example.net",
        "--crl-full-name=DNS:crl.example.com",
        "--crl-full-name=DNS:crl.example.net",
        chain=[usable_root],
    )

    extensions = ca.extensions

    # Test AuthorityInformationAccess extension
    assert extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS] == x509.Extension(
        oid=ExtensionOID.AUTHORITY_INFORMATION_ACCESS,
        critical=False,
        value=x509.AuthorityInformationAccess(
            [
                x509.AccessDescription(
                    access_method=AuthorityInformationAccessOID.OCSP,
                    access_location=dns("example.com"),
                ),
                x509.AccessDescription(
                    access_method=AuthorityInformationAccessOID.CA_ISSUERS,
                    access_location=dns("example.net"),
                ),
            ]
        ),
    )

    # Test CRL Distribution Points extension
    assert extensions[ExtensionOID.CRL_DISTRIBUTION_POINTS] == crl_distribution_points(
        distribution_point([dns("crl.example.com"), dns("crl.example.net")])
    )


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_sign_extensions(hostname: str, ca_name: str, usable_root: CertificateAuthority) -> None:
    """Test adding extensions for signed certificates."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        f"--parent={usable_root.serial}",
        # Certificate Policies extension
        "--sign-policy-identifier=anyPolicy",
        "--sign-certification-practice-statement=https://example.com/cps1/",
        "--sign-user-notice=user notice text one",
        "--sign-policy-identifier=1.2.3",
        "--sign-user-notice=user notice text two",
        "--sign-certification-practice-statement=https://example.com/cps2/",
        chain=[usable_root],
    )

    # Test Certificate Policies extension
    assert ExtensionOID.CERTIFICATE_POLICIES not in ca.extensions
    assert ca.sign_certificate_policies == certificate_policies(
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("2.5.29.32.0"),
            policy_qualifiers=[
                "https://example.com/cps1/",
                x509.UserNotice(notice_reference=None, explicit_text="user notice text one"),
            ],
        ),
        x509.PolicyInformation(
            policy_identifier=x509.ObjectIdentifier("1.2.3"),
            policy_qualifiers=[
                x509.UserNotice(notice_reference=None, explicit_text="user notice text two"),
                "https://example.com/cps2/",
            ],
        ),
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_multiple_ians(hostname: str, ca_name: str) -> None:
    """Test that we can set multiple IssuerAlternativeName values."""
    ca = init_ca_e2e(
        ca_name,
        "--sign-issuer-alternative-name=example.com",
        "--sign-issuer-alternative-name=https://example.com",
        f"CN={hostname}",
    )
    assert ca.sign_issuer_alternative_name == issuer_alternative_name(
        dns("example.com"), uri("https://example.com")
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_acme_arguments(hostname: str, ca_name: str) -> None:
    """Test ACME arguments."""
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        "--acme-enable",
        "--acme-disable-account-registration",
        "--acme-contact-optional",
        "--acme-profile=client",
    )

    assert ca.acme_enabled is True
    assert ca.acme_registration is False
    assert ca.acme_profile == "client"
    assert ca.acme_requires_contact is False


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_api_arguments(hostname: str, ca_name: str) -> None:
    """Test REST API arguments."""
    ca = init_ca_e2e(ca_name, f"CN={hostname}", "--api-enable")

    assert ca.api_enabled is True


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_leading_zero(ca_name: str) -> None:
    """Assert that CA serials are stored without leading zeroes."""
    with patch("django_ca.managers.x509.random_serial_number", return_value=16 * 16 * 16 - 1):
        ca = init_ca(name=ca_name)
    assert ca.serial == "FFF"


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_disabled_arguments(settings: SettingsWrapper) -> None:
    """Test that ACME/REST API options don't work when feature is disabled."""
    settings.CA_ENABLE_ACME = False
    settings.CA_ENABLE_REST_API = False
    command = ["init_ca", "Test CA", "CN=example.com"]
    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-enable"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-disable"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-disable-account-registration"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-enable-account-registration"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-contact-optional"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--acme-profile=client"])

    with assert_system_exit(2):
        cmd_e2e([*command, "--api-enable"])


@pytest.mark.usefixtures("tmpcadir")
def test_unknown_acme_profile(hostname: str, ca_name: str) -> None:
    """Test naming an unknown profile."""
    with assert_command_error(r"^unknown-profile: Profile is not defined\.$"):
        cmd("init_ca", ca_name, f"CN={hostname}", acme_profile="unknown-profile")


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_ocsp_responder_arguments(hostname: str, ca_name: str) -> None:
    """Test ACME arguments."""
    ca = init_ca_e2e(
        ca_name, f"CN={hostname}", "--ocsp-responder-key-validity=10", "--ocsp-response-validity=3600"
    )

    assert ca.ocsp_responder_key_validity == 10
    assert ca.ocsp_response_validity == 3600


@pytest.mark.usefixtures("tmpcadir")
def test_invalid_ocsp_responder_arguments() -> None:
    """Test naming an unknown profile."""
    assert_e2e_error(
        ["init_ca", "CN=example.com", "--ocsp-responder-key-validity=0"],
        stderr=re.compile(r"--ocsp-responder-key-validity: DAYS must be equal or greater then 1\."),
    )

    assert_e2e_error(
        ["init_ca", "CN=example.com", "--ocsp-response-validity=10"],
        stderr=re.compile(r"--ocsp-response-validity: SECONDS must be equal or greater then 600\."),
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_ec(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test creating an ECC CA."""
    with assert_create_ca_signals() as (_pre, post):
        ca = init_ca(name=ca_name, key_type="EC")
    assert_post_create_ca(post, ca)
    assert isinstance(key_backend.get_key(ca, use_options), ec.EllipticCurvePrivateKey)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_dsa(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test creating a certificate authority with a DSA private key."""
    with assert_create_ca_signals() as (_pre, post):
        ca = init_ca(name=ca_name, key_type="DSA")
    assert_post_create_ca(post, ca)

    key = key_backend.get_key(ca, use_options)
    assert isinstance(key, dsa.DSAPrivateKey)
    assert key.key_size == 1024


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_permitted(hostname: str, ca_name: str) -> None:
    """Test the NameConstraints extension with 'permitted'."""
    ca = init_ca_e2e(ca_name, "--permit-name", "DNS:.com", f"CN={hostname}")
    assert ca.extensions[ExtensionOID.NAME_CONSTRAINTS] == name_constraints(
        permitted=[dns(".com")], critical=True
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_excluded(hostname: str, ca_name: str) -> None:
    """Test the NameConstraints extension with 'excluded'."""
    ca = init_ca_e2e(ca_name, "--exclude-name", "DNS:.com", f"CN={hostname}")
    assert ca.extensions[ExtensionOID.NAME_CONSTRAINTS] == name_constraints(
        excluded=[dns(".com")], critical=True
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_no_path_length(ca_name: str) -> None:
    """Test creating a CA with no path length."""
    with assert_create_ca_signals() as (_pre, post):
        ca = init_ca(name=ca_name, path_length=None)
    assert_post_create_ca(post, ca)
    ca.full_clean()  # assert e.g. max_length in serials
    assert_signature([ca], ca)
    assert ca.max_path_length is None
    assert ca.path_length is None
    assert ca.allows_intermediate_ca is True
    assert ca.issuer == ca.subject
    assert_authority_key_identifier(ca, ca)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_empty_subject_fields(hostname: str, ca_name: str) -> None:
    """Test creating a CA with empty subject fields."""
    with assert_create_ca_signals() as (_pre, post):
        out, err = cmd("init_ca", ca_name, f"L=,CN={hostname}")
    ca = CertificateAuthority.objects.get(name=ca_name)
    assert out == f"{add_colons(ca.serial)}\n"
    assert err == ""

    assert_post_create_ca(post, ca)
    ca.full_clean()  # assert e.g. max_length in serials
    assert_signature([ca], ca)
    assert ca.pub.loaded.subject == x509.Name(
        [x509.NameAttribute(NameOID.LOCALITY_NAME, ""), x509.NameAttribute(NameOID.COMMON_NAME, hostname)]
    )
    assert_authority_key_identifier(ca, ca)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_with_no_output(hostname: str, ca_name: str) -> None:
    """Test creating a CA with no output."""
    with assert_create_ca_signals():
        out, err = cmd("init_ca", ca_name, f"CN={hostname}", output_format="none")
    assert out == ""
    assert err == ""


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_no_cn(ca_name: str) -> None:
    """Test creating a CA with no CommonName."""
    subject = "C=AT,ST=Vienna,L=Vienna,O=Org,OU=OrgUnit"
    error = r"^Subject must contain a common name \(CN=\.\.\.\)\.$"
    with assert_create_ca_signals(False, False), assert_command_error(error):
        cmd("init_ca", ca_name, subject)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_intermediate_check(ca_name: str) -> None:
    """Test intermediate path length checks."""
    with assert_create_ca_signals() as (_pre, post):
        path_length_1 = init_ca(name=f"{ca_name}-1", path_length=1)
    assert_post_create_ca(post, path_length_1)
    path_length_1.full_clean()  # assert e.g. max_length in serials
    assert path_length_1.path_length == 1
    assert path_length_1.max_path_length == 1
    assert path_length_1.allows_intermediate_ca is True

    with assert_create_ca_signals() as (_pre, post):
        path_length_1_none = init_ca(name=f"{ca_name}-2", path_length=None, parent=path_length_1)
    assert_post_create_ca(post, path_length_1_none)
    path_length_1_none.full_clean()  # assert e.g. max_length in serials

    # path_length_1_none cannot have an intermediate CA because parent has path_length=1
    assert path_length_1_none.path_length is None
    assert path_length_1_none.max_path_length == 0
    assert path_length_1_none.allows_intermediate_ca is False
    with (
        assert_command_error(r"^Parent CA cannot create intermediate CA due to path length restrictions\.$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name="wrong", parent=path_length_1_none)

    with assert_create_ca_signals() as (_pre, post):
        path_length_1_three = init_ca(name="path-length-1-three", path_length=3, parent=path_length_1)
    assert_post_create_ca(post, path_length_1_three)
    path_length_1_three.full_clean()  # assert e.g. max_length in serials

    # path_length_1_none cannot have an intermediate CA because parent has path_length=1
    assert path_length_1_three.path_length == 3
    assert path_length_1_three.max_path_length == 0
    assert path_length_1_three.allows_intermediate_ca is False
    with (
        assert_command_error(r"^Parent CA cannot create intermediate CA due to path length restrictions\.$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name="wrong", parent=path_length_1_none)

    with assert_create_ca_signals() as (_pre, post):
        path_length_none = init_ca(name="path-length-none", path_length=None)
    assert_post_create_ca(post, path_length_none)
    path_length_none.full_clean()  # assert e.g. max_length in serials
    assert path_length_none.path_length is None
    assert path_length_none.max_path_length is None
    assert path_length_none.allows_intermediate_ca is True

    with assert_create_ca_signals() as (_pre, post):
        path_length_none_none = init_ca(
            name="path-length-none-none", path_length=None, parent=path_length_none
        )
    assert_post_create_ca(post, path_length_none_none)
    path_length_none_none.full_clean()  # assert e.g. max_length in serials
    assert path_length_none_none.path_length is None
    assert path_length_none_none.max_path_length is None

    with assert_create_ca_signals() as (_pre, post):
        path_length_none_1 = init_ca(name="path-length-none-1", path_length=1, parent=path_length_none)
    assert_post_create_ca(post, path_length_none_1)
    path_length_none_1.full_clean()  # assert e.g. max_length in serials
    assert path_length_none_1.path_length == 1
    assert path_length_none_1.max_path_length == 1


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_expires_override(ca_name: str, usable_root: CertificateAuthority) -> None:
    """Test that if we request an expiry after that of the parent, we override to that of the parent."""
    expires = usable_root.not_after - timezone.now() + timedelta(days=10)
    with assert_create_ca_signals() as (_pre, post):
        child = init_ca(name=ca_name, parent=usable_root, expires=expires)
    assert_post_create_ca(post, child)
    child.full_clean()  # assert e.g. max_length in serials
    assert_signature([usable_root], child)

    assert usable_root.not_after == child.not_after
    assert usable_root.parent is None
    assert child.parent == usable_root
    assert not list(child.children.all())
    assert list(usable_root.children.all()) == [child]
    assert_authority_key_identifier(usable_root, child)


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_expires_override_with_use_tz_false(
    settings: SettingsWrapper, ca_name: str, usable_root: CertificateAuthority
) -> None:
    """Test silently limiting expiry if USE_TZ=False."""
    settings.USE_TZ = False
    usable_root.refresh_from_db()
    expires = usable_root.not_after - timezone.now() + timedelta(days=10)
    ca = init_ca(name=ca_name, expires=expires, parent=usable_root)
    assert ca.not_after.tzinfo is None
    assert ca.not_after == usable_root.not_after


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_password(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test creating a CA with a password."""
    password = b"testpassword"
    with assert_create_ca_signals() as (_pre, post):
        parent = init_ca(name=f"{ca_name}-parent", password=password, path_length=1)
    assert_post_create_ca(post, parent)
    parent.full_clean()  # assert e.g. max_length in serials
    assert_signature([parent], parent)

    # Assert that we cannot access this without a password
    msg = "^Password was not given but private key is encrypted$"
    parent = CertificateAuthority.objects.get(name=f"{ca_name}-parent")
    with pytest.raises(TypeError, match=msg):
        key_backend.get_key(parent, use_options)

    # Wrong password doesn't work either
    with pytest.raises(ValueError):  # noqa: PT011  # cryptography controls the error message
        # NOTE: cryptography is notoriously unstable when it comes to the error message here, so we only
        # check the exception class.
        key_backend.get_key(parent, StoragesUsePrivateKeyOptions(password=b"wrong"))

    # test the private key
    key = key_backend.get_key(parent, StoragesUsePrivateKeyOptions(password=password))
    assert isinstance(key, RSAPrivateKey)
    assert key.key_size == 1024

    # create a child ca, also password protected
    child_password = b"childpassword"
    parent = CertificateAuthority.objects.get(name=f"{ca_name}-parent")  # Get again, key is cached

    with (
        assert_command_error(r"^Password was not given but private key is encrypted$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name=f"{ca_name}-child", parent=parent, password=password)
    assert CertificateAuthority.objects.filter(name=f"{ca_name}-child").exists() is False

    # Create again with parent ca
    with assert_create_ca_signals() as (_pre, post):
        init_ca(name=f"{ca_name}-child", parent=parent, password=child_password, parent_password=password)

    child = CertificateAuthority.objects.get(name=f"{ca_name}-child")
    assert_post_create_ca(post, child)
    child.full_clean()  # assert e.g. max_length in serials
    assert_signature([parent], child)


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
def test_parent_password_with_ca_passwords(
    ca_name: str, usable_pwd: CertificateAuthority, settings: SettingsWrapper
) -> None:
    """Use a password-encrypted parent where the password is stored in the CA_PASSWORDS setting."""
    settings.CA_PASSWORDS = {usable_pwd.serial: CERT_DATA[usable_pwd.name]["password"]}

    with assert_create_ca_signals():
        ca = init_ca(name=ca_name, parent=usable_pwd)
    assert ca.parent == usable_pwd


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_default_hostname(hostname: str, ca_name: str, usable_root: CertificateAuthority) -> None:
    """Test manually passing a default hostname.

    Note: freeze time b/c this test uses root CA as a parent.
    """
    with assert_create_ca_signals() as (_pre, post):
        ca = init_ca(name=ca_name, parent=usable_root, default_hostname=hostname)
    assert_post_create_ca(post, ca)

    # Test signing extensions
    assert ca.sign_authority_information_access == authority_information_access(
        ca_issuers=[uri(f"http://{hostname}/django_ca/issuer/{usable_root.serial}.der")],
        ocsp=[uri(f"http://{hostname}/django_ca/ocsp/{ca.serial}/cert/")],
    )
    crl_urlpath = reverse("django_ca:crl", kwargs={"serial": ca.serial})
    assert ca.sign_crl_distribution_points == crl_distribution_points(
        distribution_point([uri(f"http://{hostname}{crl_urlpath}")])
    )

    ca_crl_urlpath = reverse("django_ca:ca-crl", kwargs={"serial": usable_root.serial})
    assert ca.extensions[ExtensionOID.CRL_DISTRIBUTION_POINTS] == crl_distribution_points(
        distribution_point([uri(f"http://{hostname}{ca_crl_urlpath}")])
    )
    assert ca.extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS] == authority_information_access(
        ca_issuers=[uri(f"http://{hostname}/django_ca/issuer/{usable_root.serial}.der")],
        ocsp=[uri(f"http://{hostname}/django_ca/ocsp/{usable_root.serial}/ca/")],
    )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_no_default_hostname(ca_name: str) -> None:
    """Disable default hostname via the command line."""
    with assert_create_ca_signals() as (_pre, post):
        ca = init_ca(name=ca_name, default_hostname=False)
    assert_post_create_ca(post, ca)

    assert ExtensionOID.AUTHORITY_INFORMATION_ACCESS not in ca.extensions
    assert ExtensionOID.CRL_DISTRIBUTION_POINTS not in ca.extensions
    assert ca.sign_authority_information_access is None
    assert ca.sign_crl_distribution_points is None
    assert ca.sign_issuer_alternative_name is None


@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])
@pytest.mark.usefixtures("mock_tasks")
def test_multiple_ocsp_and_ca_issuers(hostname: str, ca_name: str, usable_root: CertificateAuthority) -> None:
    """Test using multiple OCSP responders and CA issuers."""
    ocsp_uri_one = "http://ocsp.example.com/one"
    ocsp_uri_two = "http://ocsp.example.net/two"
    issuer_uri_one = "http://issuer.example.com/one"
    issuer_uri_two = "http://issuer.example.com/two"
    ca = init_ca_e2e(
        ca_name,
        f"CN={hostname}",
        f"--parent={usable_root.serial}",
        # NOTE: mixing the order of arguments here. This way we make sure that the values are properly
        # sorted (by method) in the assertion for the extension.
        f"--ocsp-responder={ocsp_uri_one}",
        f"--ca-issuer={issuer_uri_one}",
        f"--ocsp-responder={ocsp_uri_two}",
        f"--ca-issuer={issuer_uri_two}",
        chain=[usable_root],
    )

    actual = ca.extensions[ExtensionOID.AUTHORITY_INFORMATION_ACCESS]
    expected = authority_information_access(
        [uri(issuer_uri_one), uri(issuer_uri_two)], [uri(ocsp_uri_one), uri(ocsp_uri_two)]
    )
    assert actual == expected


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
def test_non_default_key_backend_with_rsa_key(
    ca_name: str,
    rfc4514_subject: str,
    secondary_backend: StoragesBackend,
    generate_crl: MagicMock,
    generate_ocsp_key: MagicMock,
) -> None:
    """Test creating a key with a non-default key backend."""
    password = "secure-password"
    ca = init_ca_e2e(
        ca_name,
        rfc4514_subject,
        "--key-backend=secondary",
        "--secondary-path=secondary-ca-path",
        "--key-size=2048",
        "--path-length=1",
        f"--secondary-password={password}",
    )
    assert ca.key_backend_alias == "secondary"
    assert ca.key_backend_options["path"].startswith("secondary-ca-path")
    options = StoragesUsePrivateKeyOptions(password=password.encode())

    key = secondary_backend.get_key(ca, options)
    assert isinstance(key, RSAPrivateKey)
    assert key.key_size == 2048

    # Create a child CA to test parent password
    child = init_ca_e2e(
        f"{ca_name} child",
        rfc4514_subject,
        f"--parent={ca.serial}",
        f"--secondary-parent-password={password}",
        chain=[ca],
    )
    assert child.key_backend_alias == "default"

    parent_message = UseCertificateAuthorityTaskArgs(
        serial=ca.serial, key_backend_options=options.model_dump(mode="json", exclude_unset=True)
    )
    child_message = UseCertificateAuthorityTaskArgs(serial=child.serial)

    generate_crl.assert_has_calls([call(parent_message), call(child_message)])
    generate_ocsp_key.assert_has_calls([call(parent_message), call(child_message)])


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "mock_tasks")
def test_non_default_key_backend_with_ec_key(
    ca_name: str, rfc4514_subject: str, secondary_backend: StoragesBackend
) -> None:
    """Test creating an EC key with a non-default key backend."""
    # make sure that curve is not default
    assert not isinstance(model_settings.CA_DEFAULT_ELLIPTIC_CURVE, ec.SECT571R1)
    ca = init_ca_e2e(
        ca_name,
        rfc4514_subject,
        "--key-backend=secondary",
        "--key-type=EC",
        "--elliptic-curve=sect571r1",  # non default curve
    )
    assert ca.key_backend_alias == "secondary"

    key = secondary_backend.get_key(ca, use_options)
    assert isinstance(key, ec.EllipticCurvePrivateKey)
    assert isinstance(key.curve, ec.SECT571R1)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token", "mock_tasks")
@pytest.mark.parametrize("key_type", HSMBackend.supported_key_types)
@pytest.mark.hsm
def test_hsm_backend(
    ca_name: str, rfc4514_subject: str, key_type: ParsableKeyType, subject: x509.Name
) -> None:
    """Basic test for creating a key in the HSM."""
    if key_type in settings.PKCS11_EXCLUDE_KEY_TYPES:
        pytest.xfail(f"{key_type}: Key type not supported on this platform.")

    ca = init_ca_e2e(
        ca_name,
        rfc4514_subject,
        f"--key-type={key_type}",
        "--key-backend=hsm",
        f"--hsm-key-label={ca_name}",
    )

    assert ca.key_backend_alias == "hsm"
    assert ca.key_backend.is_usable(ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert ca.key_type == key_type
    assert ca.key_backend_options["key_label"] == ca_name
    assert ca.key_backend_options["key_type"] == key_type
    assert isinstance(ca.pub.loaded, x509.Certificate)
    assert isinstance(ca.pub.loaded.public_key(), constants.PUBLIC_KEY_TYPE_MAPPING[key_type])

    # Sign a certificate to make sure that the key is actually usable
    cert_data = CERT_DATA["root-cert"]
    csr = cert_data["csr"]["parsed"]
    cert = Certificate.objects.create_cert(
        ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN), csr, subject=subject
    )
    assert_signature([ca], cert)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
@pytest.mark.parametrize("key_type", DBBackend.supported_key_types)
@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])  # otherwise CRLs might have rounding errors
def test_db_backend(
    ca_name: str, rfc4514_subject: str, key_type: ParsableKeyType, subject: x509.Name
) -> None:
    """Basic test for creating a key in the database."""
    ca = init_ca_e2e(
        ca_name, rfc4514_subject, f"--key-type={key_type}", "--key-backend=db", "--ocsp-key-backend=db"
    )

    assert ca.key_backend_alias == "db"
    assert ca.key_backend.is_usable(ca, DBUsePrivateKeyOptions())
    assert ca.key_backend.check_usable(ca, DBUsePrivateKeyOptions()) is None

    assert ca.key_type == key_type
    assert isinstance(ca.pub.loaded, x509.Certificate)
    assert isinstance(ca.pub.loaded.public_key(), constants.PUBLIC_KEY_TYPE_MAPPING[key_type])

    # Check CRLs and OCSP responder certificate
    assert_crls(ca)
    ocsp_key = assert_ocsp_responder_certificate(ca)
    assert ca.ocsp_key_backend_alias == "db"
    assert "pem" in ca.ocsp_key_backend_options["private_key"]
    assert ca.ocsp_key_backend_options["certificate"] == {"pem": ocsp_key.pub.pem, "pk": ocsp_key.pk}

    # Sign a certificate to make sure that the key is actually usable
    cert_data = CERT_DATA["root-cert"]
    csr = cert_data["csr"]["parsed"]
    cert = Certificate.objects.create_cert(ca, DBUsePrivateKeyOptions(), csr, subject=subject)
    assert_signature([ca], cert)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
@pytest.mark.freeze_time(TIMESTAMPS["everything_valid"])  # otherwise CRLs might have rounding errors
def test_hsm_with_rsa_options(ca_name: str, rfc4514_subject: str) -> None:
    """Basic test for creating a key in the HSM."""
    assert settings.CA_MIN_KEY_SIZE == 1024  # assert initial state
    ca = init_ca_e2e(
        ca_name,
        rfc4514_subject,
        "--key-type=RSA",
        "--key-backend=hsm",
        f"--hsm-key-label={ca_name}",
        "--ocsp-key-backend=hsm",
        "--key-size=2048",  # RSA specific option
    )

    assert ca.key_backend_alias == "hsm"
    assert ca.key_backend.is_usable(ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert ca.key_type == "RSA"
    assert ca.key_backend_options["key_label"] == ca_name
    assert ca.key_backend_options["key_type"] == "RSA"
    assert isinstance(ca.pub.loaded, x509.Certificate)
    public_key = ca.pub.loaded.public_key()
    assert isinstance(public_key, RSAPublicKey)
    assert public_key.key_size == 2048

    # Check CRLs and OCSP responder certificate
    assert_crls(ca)
    assert_ocsp_responder_certificate(ca)
    assert ca.ocsp_key_backend_alias == "hsm"
    assert ca.ocsp_key_backend_options["private_key"]["key_type"] == "RSA"


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token", "mock_tasks")
@pytest.mark.parametrize("key_type", ("RSA", "EC"))
@pytest.mark.parametrize("algorithm", HSMBackend.supported_hash_algorithms)
@pytest.mark.hsm
def test_hsm_with_hash_algorithms(
    ca_name: str, key_type: str, algorithm: SignatureHashAlgorithmName, subject: x509.Name
) -> None:
    """Basic test for creating a key in the HSM."""
    ca = init_ca(
        ca_name,
        key_type=key_type,
        key_backend=key_backends["hsm"],
        hsm_key_label=ca_name,
        algorithm=constants.SIGNATURE_HASH_ALGORITHM_TYPES[algorithm](),
    )

    assert ca.key_backend_alias == "hsm"
    assert ca.key_backend.is_usable(ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert ca.key_type == key_type
    assert isinstance(
        ca.pub.loaded.signature_hash_algorithm, constants.SIGNATURE_HASH_ALGORITHM_TYPES[algorithm]
    )

    # Sign a certificate to make sure that the key is actually usable
    cert_data = CERT_DATA["root-cert"]
    csr = cert_data["csr"]["parsed"]
    cert = Certificate.objects.create_cert(
        ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN), csr, subject=subject
    )
    assert_signature([ca], cert)


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token", "mock_tasks")
@pytest.mark.parametrize("ec_curve", HSMBackend.supported_elliptic_curves)
@pytest.mark.hsm
def test_hsm_with_ec_options(ca_name: str, ec_curve: EllipticCurveName) -> None:
    """Basic test for creating a key in the HSM."""
    if ec_curve in settings.PKCS11_EXCLUDE_ELLIPTIC_CURVES:
        pytest.xfail(f"{ec_curve}: Algorithm not supported on this platform.")

    ca = init_ca(
        ca_name,
        key_type="EC",
        key_backend=key_backends["hsm"],
        hsm_key_label=ca_name,
        elliptic_curve=ec_curve,
    )

    assert ca.key_backend_alias == "hsm"
    assert ca.key_backend.is_usable(ca, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert ca.key_type == "EC"
    assert ca.key_backend_options["key_label"] == ca_name
    assert ca.key_backend_options["key_type"] == "EC"
    assert isinstance(ca.pub.loaded, x509.Certificate)
    public_key = ca.pub.loaded.public_key()
    assert isinstance(public_key, EllipticCurvePublicKey)

    # TYPEHINT NOTE: seems to be a false positive
    assert public_key.key_size == constants.ELLIPTIC_CURVE_TYPES[ec_curve].key_size  # type: ignore[comparison-overlap]
    assert public_key.curve.name == ec_curve


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_child_ca(ca_name: str) -> None:
    """Basic test for creating a key in the HSM."""
    parent_name = f"{ca_name}_parent"
    parent = init_ca(parent_name, key_backend=key_backends["hsm"], hsm_key_label=parent_name, path_length=1)

    assert parent.key_backend_alias == "hsm"
    assert parent.key_backend.is_usable(parent, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert parent.key_type == "RSA"
    assert parent.key_backend_options["key_label"] == parent_name
    assert parent.key_backend_options["key_type"] == "RSA"
    assert isinstance(parent.pub.loaded, x509.Certificate)
    assert isinstance(parent.pub.loaded.public_key(), RSAPublicKey)

    # Create a child CA in the HSM
    child_name = f"{ca_name}_child"
    child = init_ca(child_name, parent=parent, key_backend=key_backends["hsm"], hsm_key_label=child_name)
    assert child.key_backend_alias == "hsm"
    assert child.key_backend.is_usable(child, HSMUsePrivateKeyOptions(user_pin=settings.PKCS11_USER_PIN))
    assert child.key_type == "RSA"
    assert child.key_backend_options["key_label"] == child_name
    assert child.key_backend_options["key_type"] == "RSA"
    assert isinstance(child.pub.loaded, x509.Certificate)
    assert isinstance(child.pub.loaded.public_key(), RSAPublicKey)
    assert child.parent == parent


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_so_pin_overwrite(ca_name: str, settings: SettingsWrapper) -> None:
    """Test using a so_pin. At least with SoftHSM2, this yields an error currently."""
    with assert_command_error(
        r"^An operation required a login, but none was provided\. "
        r"This is most likely a bug in the underlying library, not in django-ca\.$"
    ):
        init_ca(
            ca_name,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            path_length=1,
            hsm_so_pin=settings.PKCS11_SO_PIN,
            hsm_user_pin="",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_invalid_pin(ca_name: str) -> None:
    """Test error when passing an invalid user pin."""
    with assert_command_error(r"^Pin incorrect\.$"):
        init_ca(
            ca_name,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            path_length=1,
            hsm_user_pin="wrongpin",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_invalid_so_pin(ca_name: str) -> None:
    """Test error when passing an invalid SO pin."""
    with assert_command_error(r"^Pin incorrect\.$"):
        init_ca(
            ca_name,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            path_length=1,
            hsm_so_pin="wrongpin",
            hsm_user_pin="",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_key_label_already_exists(ca_name: str) -> None:
    """Basic test for creating a key in the HSM."""
    init_ca(ca_name, key_backend=key_backends["hsm"], hsm_key_label=ca_name)
    with assert_command_error(rf"^{ca_name}: Private key with this label already exists\.$"):
        init_ca(ca_name, key_backend=key_backends["hsm"], hsm_key_label=ca_name)
    assert CertificateAuthority.objects.all().count() == 1


def test_hsm_without_key_label(ca_name: str) -> None:
    """Test error when --key-label option is missing."""
    with assert_command_error(r"^--hsm-key-label is a required option for this key backend\.$"):
        init_ca(name=ca_name, key_backend=key_backends["hsm"])


def test_hsm_with_no_pins(ca_name: str, hsm_backend: HSMBackend) -> None:
    """Test error when --key-label option is missing."""
    hsm_backend.user_pin = None

    with assert_command_error(r"^Value error, Provide one of so_pin or user_pin\.$"):
        init_ca(
            name=ca_name,
            key_backend=hsm_backend,
            hsm_key_label=ca_name,
            hsm_so_pin="",
            hsm_user_pin="",
        )


def test_hsm_with_both_pins(ca_name: str) -> None:
    """Test error when --key-label option is missing."""
    with assert_command_error(
        r'^Both SO pin and user pin configured\. To override a pin from settings, pass --hsm-so-pin="" or '
        r'--hsm-user-pin=""\.$'
    ):
        init_ca(
            name=ca_name,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            hsm_so_pin="so-pin",
            hsm_user_pin="user-pin",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir")
@pytest.mark.usefixtures("softhsm_token")
@pytest.mark.hsm
def test_hsm_with_both_parent_pins(ca_name: str) -> None:
    """Test error when --key-label option is missing."""
    parent_name = f"{ca_name}_parent"
    parent = init_ca(parent_name, key_backend=key_backends["hsm"], hsm_key_label=parent_name, path_length=1)

    with assert_command_error(
        r"^Both SO pin and user pin configured\. To override a pin from settings, pass "
        r'--hsm-parent-so-pin="" or --hsm-parent-user-pin=""\.$'
    ):
        init_ca(
            name=ca_name,
            parent=parent,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            hsm_parent_so_pin="so-pin",
            hsm_parent_user_pin="user-pin",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.hsm
def test_hsm_with_no_parent_pins(ca_name: str, hsm_backend: HSMBackend) -> None:
    """Test error when --key-label option is missing."""
    parent_name = f"{ca_name}_parent"
    parent = init_ca(parent_name, key_backend=hsm_backend, hsm_key_label=parent_name, path_length=1)

    hsm_backend.user_pin = None
    with assert_command_error(r"^Value error, Provide one of so_pin or user_pin\.$"):
        init_ca(
            name=ca_name,
            parent=parent,
            key_backend=hsm_backend,
            hsm_key_label=ca_name,
            hsm_parent_so_pin="",
            hsm_parent_user_pin="",
        )


@pytest.mark.django_db
@pytest.mark.usefixtures("tmpcadir", "softhsm_token")
@pytest.mark.parametrize(
    "algorithm", (hashes.SHA3_224(), hashes.SHA3_256(), hashes.SHA3_384(), hashes.SHA3_512())
)
def test_hsm_with_rsa_with_unsupported_hash_algorithm(
    ca_name: str, algorithm: SignatureHashAlgorithm
) -> None:
    """Test error with unsupported SHA-3 hash algorithms."""
    name = constants.SIGNATURE_HASH_ALGORITHM_NAMES[type(algorithm)]
    msg = rf"^{name}: Algorithm not supported by hsm key backend\.$"
    assert CertificateAuthority.objects.count() == 0
    with assert_command_error(msg), assert_create_ca_signals(False, False):
        init_ca(
            name=ca_name,
            key_backend=key_backends["hsm"],
            hsm_key_label=ca_name,
            key_type="RSA",
            algorithm=algorithm,
        )
    assert CertificateAuthority.objects.count() == 0


def test_invalid_public_key_parameters(ca_name: str) -> None:
    """Test passing invalid public key parameters."""
    msg = r"^Ed25519 keys do not allow an algorithm for signing\.$"
    with assert_command_error(msg), assert_create_ca_signals(False, False):
        init_ca(name=ca_name, key_type="Ed25519", algorithm=hashes.SHA256())


def test_unsupported_elliptic_curve(ca_name: str, settings: SettingsWrapper) -> None:
    """Test passing a valid elliptic curve that is not supported by the backend."""
    settings.CA_KEY_BACKENDS = {
        **settings.CA_KEY_BACKENDS,
        "dummy": {
            "BACKEND": f"{DummyBackend.__module__}.DummyBackend",
            "OPTIONS": {},
        },
    }
    with assert_command_error(r"^secp384r1: Elliptic curve not supported by dummy key backend\.$"):
        # secp384r1 is not supported by secondary backend
        init_ca(name=ca_name, key_type="EC", key_backend=key_backends["dummy"], elliptic_curve="secp384r1")


def test_root_ca_crl_url(ca_name: str) -> None:
    """Test that you cannot create a CA with a CRL URL."""
    with (
        assert_command_error(r"^CRLs cannot be used to revoke root CAs\.$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name=ca_name, crl_full_name="https://example.com")


def test_root_ca_ocsp_responder(ca_name: str) -> None:
    """Test that you cannot create a root CA with a OCSP responder."""
    aia = authority_information_access(ocsp=[uri("http://example.com")])
    with (
        assert_command_error(r"^URI:http://example.com: OCSP responder cannot be added to root CAs\.$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name=ca_name, authority_information_access=aia.value)


def test_root_ca_issuer(ca_name: str) -> None:
    """Test that you cannot create a root CA with a CA issuer field."""
    aia = authority_information_access(ca_issuers=[uri("http://example.com")])
    with (
        assert_command_error(r"^URI:http://example.com: CA issuer cannot be added to root CAs\.$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(name=ca_name, authority_information_access=aia.value)


def test_key_type_not_supported_by_backend(settings: SettingsWrapper, ca_name: str) -> None:
    """Test creating a key with a type that is not supported by the selected backend."""
    settings.CA_KEY_BACKENDS = {
        **settings.CA_KEY_BACKENDS,
        "dummy": {
            "BACKEND": f"{DummyBackend.__module__}.DummyBackend",
            "OPTIONS": {},
        },
    }
    with assert_command_error(r"^DSA: Key type not supported by dummy key backend\.$"):
        init_ca(ca_name, key_backend=key_backends["dummy"], key_type="DSA")


def test_algorithm_not_supported_by_backend(settings: SettingsWrapper, ca_name: str) -> None:
    """Test creating a key with a type that is not supported by the selected backend."""
    settings.CA_KEY_BACKENDS = {
        **settings.CA_KEY_BACKENDS,
        "dummy": {
            "BACKEND": f"{DummyBackend.__module__}.DummyBackend",
            "OPTIONS": {},
        },
    }
    with assert_command_error(r"^SHA-384: Algorithm not supported by dummy key backend\.$"):
        init_ca(ca_name, key_backend=key_backends["dummy"], key_type="RSA", algorithm=hashes.SHA384())


def test_small_key_size(ca_name: str) -> None:
    """Test creating a key with a key size that is too small."""
    with (
        assert_command_error(r"^key_size: Input should be greater than or equal to 1024$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(ca_name, key_size=256)


def test_key_not_power_of_two(ca_name: str) -> None:
    """Test creating a key with invalid key size."""
    with (
        assert_command_error(r"^key_size: Value error, 2049: Must be a power of two$"),
        assert_create_ca_signals(False, False),
    ):
        init_ca(ca_name, key_size=2049)


def test_multiple_validation_errors(ca_name: str) -> None:
    """Test case where multiple validation errors are thrown."""
    msg = r"""2 errors:
\* key_size: Input should be a valid integer, unable to parse string as an integer
\* password: Input should be a valid bytes"""
    with assert_command_error(msg), assert_create_ca_signals(False, False):
        init_ca(ca_name, key_size="not-an-int", password=123)


@pytest.mark.parametrize("key_type", ("RSA", "DSA", "Ed448", "Ed25519"))
def test_non_ec_key_with_elliptic_curve(ca_name: str, key_type: str) -> None:
    """Test creating a key with an elliptic curve where the key type does not support it."""
    msg = rf"^Value error, Elliptic curves are not supported for {key_type} keys\.$"
    with assert_command_error(msg), assert_create_ca_signals(False, False):
        init_ca(ca_name, key_type=key_type, elliptic_curve=ec.SECT571R1())


@pytest.mark.parametrize("key_type", ("EC", "Ed448", "Ed25519"))
def test_key_size_with_unsupported_key_type(ca_name: str, key_type: str) -> None:
    """Test creating a key with a key size where the key type does not support it."""
    msg = rf"^Value error, Key size is not supported for {key_type} keys\.$"
    with assert_command_error(msg), assert_create_ca_signals(False, False):
        init_ca(ca_name, key_type=key_type, key_size=2048)


@pytest.mark.skipif(CRYPTOGRAPHY_VERSION < (43,), reason="cryptography check was added in version 43")
@pytest.mark.parametrize(
    ("value", "msg"),
    (
        ("", r"Attribute's length must be >= 1 and <= 64, but it was 0"),
        ("X" * 65, r"Attribute's length must be >= 1 and <= 64, but it was 65"),
    ),
)
def test_invalid_common_name(value: str, msg: str) -> None:
    """Test passing an invalid common name in the subject."""
    with assert_command_error(msg):
        init_ca(value)


def test_unparsable_subject(ca_name: str) -> None:
    """Test error when you pass an unparsable subject."""
    with assert_command_error(r"/CN=example\.com: Could not parse name as RFC 4514 string\.$"):
        cmd("init_ca", ca_name, "/CN=example.com")


@pytest.mark.django_db
def test_get_use_private_key_options_raises_command_error(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test error handling when get_use_private_key_options() raises CommandError."""
    msg = "some command error"
    exc = CommandError(msg, returncode=3)
    with assert_command_error(rf"^{msg}$", returncode=3):
        with patch.object(key_backend, "get_use_private_key_options", side_effect=exc):
            init_ca(ca_name, key_backend=key_backend)


@pytest.mark.django_db
def test_get_use_private_key_options_raises_exception(ca_name: str, key_backend: StoragesBackend) -> None:
    """Test error handling when get_use_private_key_options() raises a generic Excpetion."""
    msg = "some command error"
    exc = Exception(msg)
    with pytest.raises(Exception, match=rf"^{msg}$"):
        with patch.object(key_backend, "get_use_private_key_options", side_effect=exc):
            init_ca(ca_name, key_backend=key_backend)
